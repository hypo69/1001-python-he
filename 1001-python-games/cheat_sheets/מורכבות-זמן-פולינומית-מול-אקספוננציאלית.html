<h3 dir="rtl">**זמן פולינומי**</h3>
<p dir="rtl">**זמן פולינומי** — זהו מונח המשמש בתורת הסיבוכיות החישובית לתיאור זמן הריצה של אלגוריתם, הגדל כפולינום (רב-איבר) של גודל הקלט. אם זמן הריצה של אלגוריתם ניתן לביטוי כ- \(<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><span dir="ltr">O(n</span>^<span dir="ltr">k</span>)</<span dir="ltr">span</span>>\), כאשר \(<span dir="ltr">n</span>\) — גודל הקלט, ו- \(<span dir="ltr">k</span>\) — קבוע, אז אלגוריתם כזה פועל בזמן פולינומי.</p>
<h4 dir="rtl">**דוגמאות:**</h4>
<li dir="rtl">**מיון רשימה**: אלגוריתמים כמו מיון מיזוג או מיון מהיר פועלים ב- \(<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><span dir="ltr">O(n</span> \<span dir="ltr">log</span> <span dir="ltr">n</span>)</<span dir="ltr">span</span>>\), שהוא זמן פולינומי.</li>
<li dir="rtl">**מציאת המסלול הקצר ביותר בגרף**: אלגוריתם דייקסטרה פועל ב- \(<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><span dir="ltr">O(n</span>^2)</<span dir="ltr">span</span>>\) או \(<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><span dir="ltr">O(n</span> \<span dir="ltr">log</span> <span dir="ltr">n</span>)</<span dir="ltr">span</span>>\) בהתאם ליישום, וגם הוא פולינומי.</li>
<h4 dir="rtl">**מאפיינים:**</h4>
<p dir="rtl">- אלגוריתמים הפועלים בזמן פולינומי נחשבים **יעילים** ו**ישימים בפועל**.</p>
<p dir="rtl">- בעיות שניתן לפתור בזמן פולינומי שייכות למחלקה **<span dir="ltr">P</span>**.</p>
<p dir="rtl">---</p>
<h3 dir="rtl">**זמן אקספוננציאלי**</h3>
<p dir="rtl">**זמן אקספוננציאלי** — זהו זמן הריצה של אלגוריתם, הגדל באופן אקספוננציאלי בהתאם לגודל הקלט. אם זמן הריצה ניתן לביטוי כ- \(<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><span dir="ltr">O(k</span>^<span dir="ltr">n</span>)</<span dir="ltr">span</span>>\), כאשר \(<span dir="ltr">n</span>\) — גודל הקלט, ו- \(<span dir="ltr">k</span>\) — קבוע, אז אלגוריתם כזה פועל בזמן אקספוננציאלי.</p>
<h4 dir="rtl">**דוגמאות:**</h4>
<li dir="rtl">**בעיית הסוכן הנוסע**: פתרון בשיטת כוח גס של כל המסלולים האפשריים דורש \(<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><span dir="ltr">O(n</span>!)</<span dir="ltr">span</span>>\) זמן, שגרוע יותר מאקספוננציאלי.</li>
<li dir="rtl">**מעבר על כל תתי-הקבוצות**: אלגוריתם הבודק את כל תתי-הקבוצות האפשריות של קבוצה בת \(<span dir="ltr">n</span>\) איברים, פועל ב- \(<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><span dir="ltr">O(2</span>^<span dir="ltr">n</span>)</<span dir="ltr">span</span>>\).</li>
<h4 dir="rtl">**מאפיינים:**</h4>
<p dir="rtl">- אלגוריתמים הפועלים בזמן אקספוננציאלי נחשבים **לא יעילים** עבור קלטים גדולים, מכיוון שזמן הריצה הופך לגדול באופן בלתי מעשי גם עבור \(<span dir="ltr">n</span>\) קטן יחסית.</p>
<p dir="rtl">- בעיות שניתן לפתור רק בזמן אקספוננציאלי, שייכות לעתים קרובות למחלקות **<span dir="ltr">NP</span>-קשות** או **<span dir="ltr">NP</span>-שלמות**.</p>
<p dir="rtl">---</p>
<h3 dir="rtl">**השוואת זמן פולינומי ואקספוננציאלי**</h3>
<p dir="rtl">| **מאפיין**            | **זמן פולינומי**               | **זמן אקספוננציאלי**               |</p>
<p dir="rtl">| ----------------------------- | -------------------------------------- | ---------------------------------------- |</p>
<p dir="rtl">| **גידול זמן ריצה**   | איטי (לדוגמה, \(<span dir="ltr">n</span>^2\), \(<span dir="ltr">n</span>^3\)) | מהיר (לדוגמה, \(2^<span dir="ltr">n</span>\), \(3^<span dir="ltr">n</span>\))     |</p>
<p dir="rtl">| **דוגמאות לבעיות**             | מיון, מציאת המסלול הקצר ביותר     | בעיית הסוכן הנוסע, מעבר על תתי-קבוצות |</p>
<p dir="rtl">| **ישימות מעשית** | יעיל עבור נתונים גדולים          | לא ישים עבור נתונים גדולים            |</p>
<p dir="rtl">| **מחלקה סיבוכיות**           | <span dir="ltr">P</span>                                      | <span dir="ltr">NP</span>-קשות, <span dir="ltr">NP</span>-שלמות                    |</p>
<p dir="rtl">---</p>
<h3 dir="rtl">**למה זה חשוב?**</h3>
<li dir="rtl">**זמן פולינומי**:</li>
<p dir="rtl">- אלגוריתמים הפועלים בזמן פולינומי נחשבים **ישימים בפועל**, מכיוון שהם יכולים לעבד כמויות גדולות של נתונים בזמן סביר.</p>
<p dir="rtl">- בעיות ממחלקת **<span dir="ltr">P</span>** (פתירות בזמן פולינומי) הן הבסיס ליישומים רבים במדעי המחשב, כגון עיבוד נתונים, רשתות, קריפטוגרפיה ובינה מלאכותית.</p>
<li dir="rtl">**זמן אקספוננציאלי**:</li>
<p dir="rtl">- אלגוריתמים הפועלים בזמן אקספוננציאלי הופכים **לבלתי מעשיים** גם עבור קלטים קטנים יחסית. לדוגמה, עבור \(<span dir="ltr">n</span> = 100\), \(2^<span dir="ltr">n</span>\) כבר עולה על מספר האטומים ביקום הנצפה.</p>
<p dir="rtl">- בעיות שניתן לפתור רק בזמן אקספוננציאלי, דורשות לעתים קרובות שימוש **בשיטות קירוב**, **היוריסטיקות** או **חישובים מקבילים**.</p>
<p dir="rtl">---</p>
<h3 dir="rtl">**דוגמה להבנה**</h3>
<p dir="rtl">תאר לעצמך שיש לך בעיה, ואתה רוצה לפתור אותה עבור \(<span dir="ltr">n</span> = 10\) ו- \(<span dir="ltr">n</span> = 100\):</p>
<p dir="rtl">- **זמן פולינומי (\(<span dir="ltr">n</span>^2\))**:</p>
<p dir="rtl">- עבור \(<span dir="ltr">n</span> = 10\): \(10^2 = 100\) פעולות.</p>
<p dir="rtl">- עבור \(<span dir="ltr">n</span> = 100\): \(100^2 = 10\,000\) פעולות.</p>
<p dir="rtl">- **זמן אקספוננציאלי (\(2^<span dir="ltr">n</span>\))**:</p>
<p dir="rtl">- עבור \(<span dir="ltr">n</span> = 10\): \(2^{10} = 1\,024\) פעולות.</p>
<p dir="rtl">- עבור \(<span dir="ltr">n</span> = 100\): \(2^{100} \<span dir="ltr">approx</span> 1.26 \<span dir="ltr">times</span> 10^{30}\) פעולות.</p>
<p dir="rtl">כפי שניתן לראות, עבור \(<span dir="ltr">n</span> = 100\) אלגוריתם פולינומי יבצע 10,000 פעולות, שזה די ריאלי, ואילו אלגוריתם אקספוננציאלי ידרוש \(1.26 \<span dir="ltr">times</span> 10^{30}\) פעולות, שזה כמעט בלתי אפשרי.</p>
<p dir="rtl">לבניית גרפים הממחישים את ההבדל בין זמן פולינומי לאקספוננציאלי, ניתן להשתמש בפונקציות מתמטיות שונות. הנה דוגמאות לפונקציות שניתן להשתמש בהן להדמיה:</p>
<p dir="rtl">---</p>
<h3 dir="rtl">**פונקציות פולינומיות**</h3>
<li dir="rtl">**פונקציה לינארית**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = <span dir="ltr">n</span> \)</p>
<p dir="rtl">דוגמה: זמן ריצה של אלגוריתם המעבד כל אלמנט פעם אחת.</p>
<li dir="rtl">**פונקציה ריבועית**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = <span dir="ltr">n</span>^2 \)</p>
<p dir="rtl">דוגמה: זמן ריצה של אלגוריתם עם לולאות מקוננות, לדוגמה, מיון בועות.</p>
<li dir="rtl">**פונקציה קובית**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = <span dir="ltr">n</span>^3 \)</p>
<p dir="rtl">דוגמה: זמן ריצה של אלגוריתם המעבד נתונים תלת-ממדיים.</p>
<li dir="rtl">**פונקציה לוגריתמית**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = \<span dir="ltr">log</span> <span dir="ltr">n</span> \)</p>
<p dir="rtl">דוגמה: זמן ריצה של חיפוש בינארי.</p>
<li dir="rtl">**פונקציה לינארית-לוגריתמית**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = <span dir="ltr">n</span> \<span dir="ltr">log</span> <span dir="ltr">n</span> \)</p>
<p dir="rtl">דוגמה: זמן ריצה של מיון מהיר או מיון מיזוג.</p>
<p dir="rtl">---</p>
<h3 dir="rtl">**פונקציות אקספוננציאליות**</h3>
<li dir="rtl">**פונקציה אקספוננציאלית**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = 2^<span dir="ltr">n</span> \)</p>
<p dir="rtl">דוגמה: זמן ריצה של אלגוריתם המונה את כל תתי-הקבוצות של קבוצה.</p>
<li dir="rtl">**פונקציה עצרתית**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = <span dir="ltr">n</span>! \)</p>
<p dir="rtl">דוגמה: זמן ריצה של אלגוריתם המונה את כל התמורות (לדוגמה, בעיית הסוכן הנוסע).</p>
<li dir="rtl">**פונקציה אקספוננציאלית עם בסיס אחר**:</li>
<p dir="rtl">\( <span dir="ltr">f(n</span>) = 3^<span dir="ltr">n</span> \)</p>
<p dir="rtl">דוגמה: זמן ריצה של אלגוריתם החוקר את כל השילובים האפשריים.</p>
<p dir="rtl">---</p>
<h3 dir="rtl">**דוגמת קוד לבניית גרפים (<span dir="ltr">Python</span>, <span dir="ltr">Matplotlib</span>)**</h3>
<pre class="line-numbers"><code class="language-python">
import matplotlib.pyplot as plt
import numpy as np

# טווח ערכי n
n = np.linspace(1, 20, 100)

# פונקציות פולינומיות
linear = n
quadratic = n**2
cubic = n**3
logarithmic = np.log(n)
nlogn = n * np.log(n)

# פונקציות אקספוננציאליות
exponential = 2**n
factorial = [np.math.factorial(int(i)) for i in n]  # עצרת מוגדרת רק עבור מספרים שלמים

# בניית גרפים
plt.figure(figsize=(10, 6))

# פונקציות פולינומיות
plt.plot(n, linear, label='לינארי: $f(n) = n$')
plt.plot(n, quadratic, label='ריבועי: $f(n) = n^2$')
plt.plot(n, cubic, label='קובי: $f(n) = n^3$')
plt.plot(n, logarithmic, label='לוגריתמי: $f(n) = \log n$')
plt.plot(n, nlogn, label='לינאריתמי: $f(n) = n \log n$')

# פונקציות אקספוננציאליות
plt.plot(n, exponential, label='אקספוננציאלי: $f(n) = 2^n$')
plt.plot(n, factorial, label='עצרת: $f(n) = n!$')

# הגדרות גרף
plt.yscale('log')  # סולם לוגריתמי לנוחות
plt.xlabel('גודל קלט (n)')
plt.ylabel('מורכבות זמן')
plt.title('השוואת מורכבות זמן פולינומית ואקספוננציאלית')
plt.legend()
plt.grid(True)
plt.show()
</code></pre>
<p dir="rtl">---</p>
<h3 dir="rtl">**מה יראה הגרף?**</h3>
<p dir="rtl">- **פונקציות פולינומיות** גדלות לאט ונשארות בתחתית הגרף.</p>
<p dir="rtl">- **פונקציות אקספוננציאליות** גדלות מהר מאוד ומזנקות למעלה כבר בערכים קטנים של \(<span dir="ltr">n</span>\).</p>
<p dir="rtl">- שימוש **בסולם לוגריתמי** (על ציר ה-<span dir="ltr">Y</span>) עוזר להמחיש את ההבדל בין פונקציות פולינומיות לאקספוננציאליות, מכיוון שערכיהן שונים בסדרי גודל.</p>
<p dir="rtl">---</p>