<h2 dir="rtl">מה זה <code>dataclass</code>?</h2>

<p dir="rtl"><code>dataclass</code> — זהו דקורטור, שהוצג בפייתון 3.7, המייצר אוטומטית שיטות מיוחדות (כגון <span dir="ltr">__init__</span>, <span dir="ltr">__repr__</span>, <span dir="ltr">__eq__</span> ואחרות) עבור מחלקות המשמשות בעיקר כקונטיינרים לנתונים. זה חוסך ממך את הצורך לכתוב הרבה קוד תבניתי.</p>

<h2 dir="rtl">למה להשתמש ב-<code>dataclass</code>?</h2>
<ol dir="rtl">
    <li><strong>קיצור קוד:</strong> במקום להגדיר ידנית שיטות <span dir="ltr">__init__</span>, <span dir="ltr">__repr__</span>, <span dir="ltr">__eq__</span> וכו', אתה פשוט מצהיר על שדות הנתונים, ו-<code>dataclass</code> יעשה את כל השאר.</li>
    <li><strong>שיפור קריאות:</strong> מחלקות הופכות לתמציתיות ומובנות יותר, מכיוון שהן מתמקדות בנתונים ולא ביישום הטכני.</li>
    <li><strong>הפחתת שגיאות:</strong> קוד שנוצר אוטומטית אמין יותר בדרך כלל מקוד שנכתב ידנית.</li>
    <li><strong>האצת פיתוח:</strong> תוכל ליצור מחלקות לעבודה עם נתונים מהר יותר, מבלי לבזבז זמן על שגרה.</li>
</ol>

<h2 dir="rtl">כיצד להשתמש ב-<code>dataclass</code>?</h2>
<p dir="rtl">ראשית, עליך לייבא את הדקורטור <code>dataclass</code> מהמודול <code>dataclasses</code>:</p>

<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass
</code></pre>

<p dir="rtl">לאחר מכן, אתה מסמן את המחלקה בדקורטור <code>@dataclass</code>, ומגדיר את שדות הנתונים כמשתני מחלקה רגילים עם הערות סוג:</p>

<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int
</code></pre>

<p dir="rtl">בדוגמה זו, <code>Point</code> — זוהי <code>dataclass</code>, שיש לה שני שדות: <code>x</code> ו-<code>y</code>, שניהם מסוג שלם. <code>dataclass</code> תיצור אוטומטית:</p>
<ul dir="rtl">
    <li>בנאי <span dir="ltr">__init__</span>, המאפשר ליצור מופעים של המחלקה, לדוגמה <span dir="ltr">Point(1, 2)</span>.</li>
    <li><span dir="ltr">__repr__</span>, המחזיר ייצוג מחרוזתי של האובייקט, לדוגמה <span dir="ltr">Point(x=1, y=2)</span>.</li>
    <li><span dir="ltr">__eq__</span>, המאפשר להשוות אובייקטים, לדוגמה <span dir="ltr">Point(1, 2) == Point(1, 2)</span>.</li>
</ul>

<h2 dir="rtl">דוגמה לשימוש פשוט</h2>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

# יצירת מופע של המחלקה
point1 = Point(1, 2)
point2 = Point(1, 2)
point3 = Point(3, 4)

# פלט
print(point1) # יוציא: Point(x=1, y=2)
print(point1 == point2) # יוציא: True
print(point1 == point3) # יוציא: False
</code></pre>

<h2 dir="rtl">אפשרויות <code>dataclass</code></h2>
<p dir="rtl"><code>dataclass</code> מספקת מספר פרמטרים להתאמה אישית של ההתנהגות:</p>
<ul dir="rtl">
    <li><code>init</code>: אם <code>True</code> (ברירת מחדל), נוצרת שיטת <span dir="ltr">__init__</span>. אם <code>False</code>, שיטת <span dir="ltr">__init__</span> לא נוצרת.</li>
    <li><code>repr</code>: אם <code>True</code> (ברירת מחדל), נוצרת שיטת <span dir="ltr">__repr__</span>. אם <code>False</code>, שיטת <span dir="ltr">__repr__</span> לא נוצרת.</li>
    <li><code>eq</code>: אם <code>True</code> (ברירת מחדל), נוצרת שיטת <span dir="ltr">__eq__</span>. אם <code>False</code>, שיטת <span dir="ltr">__eq__</span> לא נוצרת.</li>
    <li><code>order</code>: אם <code>True</code>, נוצרות שיטות השוואה (<span dir="ltr">__lt__</span>, <span dir="ltr">__le__</span>, <span dir="ltr">__gt__</span>, <span dir="ltr">__ge__</span>). ברירת המחדל היא <code>False</code>.</li>
    <li><code>unsafe_hash</code>: אם <code>False</code> (ברירת מחדל), שיטת <span dir="ltr">__hash__</span> לא נוצרת. אם <code>True</code>, שיטת <span dir="ltr">__hash__</span> תיווצר, ו-<code>dataclass</code> תהפוך לניתנת לגיבוב (hashable).</li>
    <li><code>frozen</code>: אם <code>True</code>, מופעי המחלקה יהיו בלתי ניתנים לשינוי (לקריאה בלבד). ברירת המחדל היא <code>False</code>.</li>
</ul>

<h2 dir="rtl">דוגמאות לשימוש בפרמטרים</h2>
<ol dir="rtl">
    <li>
        השבתת שיטת <span dir="ltr">__repr__</span> והפיכת המחלקה לבלתי ניתנת לשינוי
        <pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass(repr=False, frozen=True)
class Point:
    x: int
    y: int

# יצירת מופע של המחלקה
point1 = Point(1, 2)
# פלט
print(point1) # יוציא: <__main__.Point object at 0x...> (מכיוון ש-__repr__ לא מוגדר)

# שינוי מופע יגרום לשגיאה
try:
    point1.x = 10
except Exception as e:
    print(e) # יוציא: cannot assign to field 'x'
    </code></pre>
    </li>
    <li>
        הגדרת סדר, הוספת שיטת hash והפיכת המחלקה לבלתי ניתנת לשינוי
        <pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass(order=True, unsafe_hash=True, frozen=True)
class Point:
    x: int
    y: int

# יצירת מופע של המחלקה
point1 = Point(1, 2)
point2 = Point(3, 4)
point3 = Point(1, 2)
# פלט
print(point1 < point2) # יוציא: True
print(point1 == point3) # יוציא: True

# כעת ניתן להשתמש במחלקה כמפתח מילון
my_dict = {point1: "first", point2: "second"}
print(my_dict) # יוציא: {Point(x=1, y=2): 'first', Point(x=3, y=4): 'second'}
    </code></pre>
    </li>
</ol>

<h2 dir="rtl">ערכי ברירת מחדל</h2>
<p dir="rtl">תוכל להגדיר ערכי ברירת מחדל לשדות:</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass
class Point:
    x: int = 0
    y: int = 0

# יצירת מופע של המחלקה
point1 = Point()
point2 = Point(1, 2)

# פלט
print(point1) # יוציא: Point(x=0, y=0)
print(point2) # יוציא: Point(x=1, y=2)
</code></pre>
<p dir="rtl">בעת יצירת מופע של המחלקה, אם לא הועברו ערכים, ייעשה שימוש בערך ברירת המחדל.</p>

<h2 dir="rtl">שימוש ב-<code>dataclass</code> עם טיפוסים ניתנים לשינוי</h2>
<p dir="rtl">היזהר בעת שימוש בטיפוסי נתונים ניתנים לשינוי (רשימות, מילונים) כערכי ברירת מחדל. הם ייווצרו רק פעם אחת וישמשו את כל מופעי המחלקה:</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass
from typing import List

@dataclass
class BadExample:
    items: List[int] = []

bad1 = BadExample()
bad2 = BadExample()

bad1.items.append(1)
print(bad1.items) # יוציא: [1]
print(bad2.items) # יוציא: [1] 
</code></pre>
<p dir="rtl">כדי למנוע זאת, השתמש ב-<code>dataclasses.field</code> וב-<code>default_factory</code>:</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass, field
from typing import List

@dataclass
class GoodExample:
    items: List[int] = field(default_factory=list)

good1 = GoodExample()
good2 = GoodExample()

good1.items.append(1)
print(good1.items) # יוציא: [1]
print(good2.items) # יוציא: []
</code></pre>

<h2 dir="rtl">דיאגרמה</h2>
<p dir="rtl">הנה דיאגרמה המציגה את המושגים העיקריים של <code>dataclass</code>:</p>
<pre class="line-numbers"><code class="language-mermaid">
classDiagram
    class DataClass {
        <<decorator>>
        +init: bool = True
        +repr: bool = True
        +eq: bool = True
        +order: bool = False
        +unsafe_hash: bool = False
        +frozen: bool = False
        --
        +__init__(...)
        +__repr__()
        +__eq__(...)
        +__lt__(...)
        +__le__(...)
        +__gt__(...)
        +__ge__(...)
        +__hash__()
    }
    class UserDefinedClass {
        <<class>>
        +field1: type
        +field2: type
        +field3: type = defaultValue
        +field4: type = field(default_factory=...)
    }
    DataClass <|-- UserDefinedClass
</code></pre>

<h2 dir="rtl"><span dir="ltr">dict()</span>, <span dir="ltr">__dir__()</span> ותכונות נוספות של <code>dataclass</code></h2>

<ul dir="rtl">
    <li><span dir="ltr">dict()</span> לא עובד ישירות עם מופעי <code>dataclass</code>. כדי להמיר למילון, עליך להשתמש בשיטות ידניות או בספריות צד שלישי.</li>
    <li><span dir="ltr">__dir__()</span> מחזיר רשימה של כל התכונות והשיטות של האובייקט, כולל שיטות ושדות שנוצרו על ידי <code>dataclass</code>.</li>
    <li><span dir="ltr">__dataclass_fields__</span> ו-<span dir="ltr">__dataclass_params__</span> מספקים מטא-נתונים על שדות ופרמטרים של <code>dataclass</code>.</li>
</ul>

<h3 dir="rtl">1. <span dir="ltr">dict()</span> בהקשר של <code>dataclass</code></h3>
<p dir="rtl">אין תמיכה אוטומטית ב-<span dir="ltr">dict()</span>. עליך להשתמש בשיטה ידנית או ב-<span dir="ltr">__dict__</span>:</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

person = Person("Alice", 30)

# המרה ידנית
person_dict = {field.name: getattr(person, field.name) for field in dataclasses.fields(Person)}
print(person_dict)  # {'name': 'Alice', 'age': 30}

# או דרך __dict__
person_dict = person.__dict__
print(person_dict) # {'name': 'Alice', 'age': 30}
</code></pre>

<h3 dir="rtl">2. <span dir="ltr">__dir__()</span> ב-<code>dataclass</code></h3>
<p dir="rtl">השיטה <span dir="ltr">__dir__()</span> מחזירה רשימה של כל התכונות והשיטות של האובייקט:</p>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass

@dataclass
class Point:
    x: int
    y: int

    def distance(self):
        return (self.x**2 + self.y**2)**0.5

point = Point(1, 2)
print(dir(point))
# ['__class__', '__dataclass_fields__', '__dataclass_params__', ..., 'distance', 'x', 'y']
</code></pre>

<h3 dir="rtl">3. תכונות נוספות של <code>dataclass</code></h3>
<ul dir="rtl">
    <li><strong><span dir="ltr">__dataclass_fields__</span>:</strong> מילון עם מידע על שדות ה-<code>dataclass</code>.</li>
    <li><strong><span dir="ltr">__dataclass_params__</span>:</strong> מידע על הפרמטרים (כמו <span dir="ltr">frozen=True</span>).</li>
</ul>
<pre class="line-numbers"><code class="language-python">from dataclasses import dataclass, fields

@dataclass
class Point:
    x: int = 0
    y: int = 0

print(Point.__dataclass_fields__)
print(Point.__dataclass_params__)
</code></pre>