<p dir="rtl"># אלגוריתמי מיון</p>
<p dir="rtl">בחיי היומיום ובתכנות אנו נתקלים בצורך לסדר נתונים.</p>
<p dir="rtl">זה יכול להיות כל דבר: רשימת קניות, ספרים על מדף או תוצאות חיפוש.</p>
<p dir="rtl">אלגוריתמי מיון – זוהי קבוצת הוראות, העוזרות לנו לסדר אלמנטים בסדר מסוים, בין אם עולה,</p>
<p dir="rtl">יורד או לפי קריטריון אחר.</p>
<p dir="rtl">לדוגמה, אני משתמש בפירות בגדלים שונים.</p>
<p dir="rtl">**ייצוג פירות עם גדלים:**</p>
<p dir="rtl">נתאים פירות לגדלים. נשתמש בטאפלים (<span dir="ltr">tuple</span>), כאשר:</p>
<li dir="rtl">האלמנט הראשון – זהו גודל הפרי:</li>
<p dir="rtl">*   🍎 (קטן) – תפוח</p>
<p dir="rtl">*   🍐 (בינוני) – אגס</p>
<p dir="rtl">*   🍉 (גדול) – אבטיח</p>
<p dir="rtl">*   🧺 (גדול מאוד) – סלסלה</p>
<li dir="rtl">האלמנט השני – זהו מזהה ייחודי, לצורך פעולת התוכנית.</li>
<p dir="rtl">דוגמה: <<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><<span dir="ltr">code</span>>(🍎, 1)</<span dir="ltr">code</span>></<span dir="ltr">span</span>> – זהו תפוח קטן עם מזהה 1.</p>
<pre class="line-numbers"><code class="language-python">
from typing import List, Tuple

def compare_fruits(fruit1: Tuple[str, int], fruit2: Tuple[str, int]) -> int:
    """
    משווה שני פירות לפי גודל.

    Args:
        fruit1: טאפל (גודל, מזהה).
        fruit2: טאפל (גודל, מזהה).

    Returns:
        -1, אם fruit1 קטן מ-fruit2, 1, אם fruit1 גדול מ-fruit2, 0, אם שווים.
    """
    order = {"🍎": 0, "🍐": 1, "🍉": 2, "🧺": 3}  # מגדיר את סדר הפירות לפי גודל
    size1 = order.get(fruit1[0]) # מקבל את גודל הפרי הראשון
    size2 = order.get(fruit2[0]) # מקבל את גודל הפרי השני
    if size1 < size2: # אם גודל הפרי הראשון קטן יותר, מחזיר -1
        return -1
    elif size1 > size2: # אם גודל הפרי הראשון גדול יותר, מחזיר 1
        return 1
    else: # אם הגדלים שווים, מחזיר 0
      return 0
</code></pre>
<p dir="rtl">**אלגוריתמי מיון (השוואה לפי גודל פרי):**</p>
<li dir="rtl">**מיון בועות (<span dir="ltr">Bubble</span> <span dir="ltr">Sort</span>):**(בועות קלות יותר צפות מוקדם יותר)</li>
<p dir="rtl">*   האלגוריתם משווה פירות סמוכים לפי גודל. אם פרי גדול יותר מהשכן, הוא מחליף איתו מקומות.</p>
<p dir="rtl">*   תהליך זה חוזר על עצמו עד שכל רשימת הפירות ממוינת מהקטן לגדול.</p>
<p dir="rtl">*   אנלוגיה: תאר לעצמך שיש לך אקווריום עם בועות אוויר בגדלים שונים. בועות קלות יותר (המתאימות לפירות קטנים יותר) יצופו אל פני השטח מוקדם יותר מבועות כבדות יותר (המתאימות לפירות גדולים יותר). כך, פירות קלים יותר "צפים" לראש הרשימה, והכבדים יותר שוקעים לתחתית.</p>
<p dir="rtl">```<span dir="ltr">mermaid</span></p>
<p dir="rtl"><span dir="ltr">graph</span> <span dir="ltr">TD</span></p>
<p dir="rtl"><span dir="ltr">A</span>[התחלה] --> <span dir="ltr">B</span>{האם יש פירות לא ממוינים?};</p>
<p dir="rtl"><span dir="ltr">B</span> -- כן --> <span dir="ltr">C</span>[השווה שני פירות סמוכים];</p>
<p dir="rtl"><span dir="ltr">C</span> -- הראשון גדול יותר --> <span dir="ltr">D</span>[החלף מקומות];</p>
<p dir="rtl"><span dir="ltr">D</span> --> <span dir="ltr">E</span>[עבור לזוג הבא];</p>
<p dir="rtl"><span dir="ltr">C</span> -- הראשון לא גדול יותר --> <span dir="ltr">E</span>;</p>
<p dir="rtl"><span dir="ltr">E</span> --> <span dir="ltr">F</span>{האם הגיע לסוף הרשימה?};</p>
<p dir="rtl"><span dir="ltr">F</span> -- לא --> <span dir="ltr">C</span>;</p>
<p dir="rtl"><span dir="ltr">F</span> -- כן --> <span dir="ltr">G</span>{האם הייתה החלפה?};</p>
<p dir="rtl"><span dir="ltr">G</span> -- כן --> <span dir="ltr">B</span>;</p>
<p dir="rtl"><span dir="ltr">G</span> -- לא --> <span dir="ltr">H</span>[סיום];</p>
<p dir="rtl"><span dir="ltr">B</span> -- לא --> <span dir="ltr">H</span>;</p>
<p dir="rtl"><span dir="ltr">H</span>[סיום]</p>
<p dir="rtl">```</p>
<p dir="rtl">```<span dir="ltr">python</span></p>
<p dir="rtl"><span dir="ltr">def</span> <span dir="ltr">bubble_sort(fruits</span>: <span dir="ltr">List</span>[<span dir="ltr">Tuple</span>[<span dir="ltr">str</span>, <span dir="ltr">int</span>]]) -> <span dir="ltr">List</span>[<span dir="ltr">Tuple</span>[<span dir="ltr">str</span>, <span dir="ltr">int</span>]]:</p>
<p dir="rtl">"""</p>
<p dir="rtl">ממיין רשימת פירות לפי גודל, באמצעות אלגוריתם "מיון בועות".</p>
<p dir="rtl"><span dir="ltr">Args</span>:</p>
<p dir="rtl"><span dir="ltr">fruits</span>: רשימת טאפלים (גודל, מזהה).</p>
<p dir="rtl"><span dir="ltr">Returns</span>:</p>
<p dir="rtl">רשימת טאפלים ממוינת.</p>
<p dir="rtl">"""</p>
<p dir="rtl"><span dir="ltr">n</span> = <span dir="ltr">len(fruits</span>)  # מקבל את מספר הפירות</p>
<p dir="rtl"><span dir="ltr">for</span> <span dir="ltr">i</span> <span dir="ltr">in</span> <span dir="ltr">range(n</span>):  # עובר על הרשימה <span dir="ltr">n</span> פעמים</p>
<p dir="rtl"><span dir="ltr">for</span> <span dir="ltr">j</span> <span dir="ltr">in</span> <span dir="ltr">range(0</span>, <span dir="ltr">n</span> - <span dir="ltr">i</span> - 1):  # עובר על החלק הלא ממוין של הרשימה</p>
<p dir="rtl"><span dir="ltr">if</span> <span dir="ltr">compare_fruits(fruits</span>[<span dir="ltr">j</span>], <span dir="ltr">fruits</span>[<span dir="ltr">j</span> + 1]) == 1:  # אם הפרי משמאל גדול יותר מהפרי מימין</p>
<p dir="rtl"><span dir="ltr">fruits</span>[<span dir="ltr">j</span>], <span dir="ltr">fruits</span>[<span dir="ltr">j</span> + 1] = <span dir="ltr">fruits</span>[<span dir="ltr">j</span> + 1], <span dir="ltr">fruits</span>[<span dir="ltr">j</span>]  # מחליף מקומות</p>
<p dir="rtl"><span dir="ltr">return</span> <span dir="ltr">fruits</span></p>
<p dir="rtl">```</p>
<li dir="rtl">**מיון הכנסה (<span dir="ltr">Insertion</span> <span dir="ltr">Sort</span>):**</li>
<p dir="rtl">*   האלגוריתם בונה רשימה ממוינת, על ידי הוספת פירות אחד אחד. פרי חדש מוכנס למקום הנכון, כדי לשמור על הסדר לפי גודל.</p>
<p dir="rtl">*   מיון הכנסה טוב לרשימות קטנות או לאלו שבהן הנתונים כבר כמעט ממוינים.</p>
<li dir="rtl">**מיון בחירה (<span dir="ltr">Selection</span> <span dir="ltr">Sort</span>):**</li>
<p dir="rtl">*   האלגוריתם מוצא את הפרי הקטן ביותר בחלק הלא ממוין של הרשימה. לאחר מכן הוא מציב את הפרי הזה במקום הראשון בחלק הלא ממוין של הרשימה.</p>
<p dir="rtl">*   תהליך זה חוזר על עצמו עד שכל הפירות ממוינים.</p>
<p dir="rtl">*   מיון בחירה פשוט, אך לא יעיל לרשימות גדולות.</p>
<pre class="line-numbers"><code class="language-python">
def insertion_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    ממיין רשימת פירות לפי גודל, באמצעות אלגוריתם "מיון הכנסה".

    Args:
        fruits: רשימת טאפלים (גודל, מזהה).

    Returns:
        רשימת טאפלים ממוינת.
    """
    for i in range(1, len(fruits)): # מתחיל מהפרי השני (הראשון נחשב ממוין)
        key = fruits[i] # לוקח את הפרי הבא
        j = i - 1 # אינדקס הפרי הקודם
        while j >= 0 and compare_fruits(fruits[j], key) == 1: # מחפש מיקום בחלק הממוין, לאן להכניס את הפרי
            fruits[j + 1] = fruits[j] # מזיז פירות כדי לפנות מקום לחדש
            j -= 1
        fruits[j + 1] = key # מכניס את הפרי למקום הנכון
    return fruits

def selection_sort(fruits: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
    """
    ממיין רשימת פירות לפי גודל, באמצעות אלגוריתם "מיון בחירה".

    Args:
        fruits: רשימת טאפלים (גודל, מזהה).

    Returns:
        רשימת טאפלים ממוינת.
    """
    n = len(fruits) # מקבל את מספר הפירות ברשימה
    for i in range(n): # עובר על כל הפירות ברשימה
        min_index = i # אינדקס הפרי הקטן ביותר
        for j in range(i + 1, n): # מחפש את הפרי הקטן ביותר בחלק הלא ממוין
            if compare_fruits(fruits[j], fruits[min_index]) == -1: # אם נמצא פרי קטן יותר מהמינימום הנוכחי
                min_index = j # זוכר את אינדקס המינימום החדש
        fruits[i], fruits[min_index] = fruits[min_index], fruits[i] # מחליף את הפרי הנוכחי עם הקטן ביותר מהחלק הלא ממוין
    return fruits

def display_fruits(fruits: List[Tuple[str, int]]) -> str:
    """
    ממיר רשימת פירות למחרוזת להצגה.

    Args:
        fruits: רשימת טאפלים (גודל, מזהה).

    Returns:
        מחרוזת להצגת רשימת הפירות.
    """
    return ", ".join(f"{fruit[0]}{fruit[1]}" for fruit in fruits)  # מרכיב מחרוזת להדפסה


# יוצר רשימת פירות למיון
fruits = [
    ("🍉", 1), ("🍎", 2), ("🍐", 3), ("🧺", 4), ("🍎", 5), ("🍉", 6), ("🍐", 7),
    ("🍎", 8), ("🧺", 9), ("🍉", 10), ("🍐", 11), ("🍎", 12)
]

print("רשימת פירות מקורית: " + display_fruits(fruits))  # מדפיס את הרשימה המקורית
print("דוגמאות: תפוח (🍎) < אגסים (🍐) < אבטיח (🍉) < סלסלות (🧺)")  # מציג את סדר הפירות

# מיון בועות
sorted_fruits_bubble = bubble_sort(fruits.copy()) # ממיין עותק של הרשימה
print("מיון בועות: " + display_fruits(sorted_fruits_bubble)) # מדפיס את התוצאה

# מיון הכנסה
sorted_fruits_insertion = insertion_sort(fruits.copy()) # ממיין עותק של הרשימה
print("מיון הכנסה: " + display_fruits(sorted_fruits_insertion)) # מדפיס את התוצאה

# מיון בחירה
sorted_fruits_selection = selection_sort(fruits.copy()) # ממיין עותק של הרשימה
print("מיון בחירה: " + display_fruits(sorted_fruits_selection)) # מדפיס את התוצאה
</code></pre>
<p dir="rtl">**הסבר קוד:**</p>
<li dir="rtl">**<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><<span dir="ltr">code</span>><span dir="ltr">compare_fruits(fruit1</span>, <span dir="ltr">fruit2</span>)</<span dir="ltr">code</span>></<span dir="ltr">span</span>>:** פונקציה זו משווה שני פירות לפי גודל ומחזירה -1 אם הפרי הראשון קטן יותר, 1 אם גדול יותר, ו-0 אם הם שווים. אני משתמש במילון <<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><<span dir="ltr">code</span>><span dir="ltr">order</span></<span dir="ltr">code</span>></<span dir="ltr">span</span>> כדי להגדיר את סדר גודל הפירות.</li>
<li dir="rtl">**<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><<span dir="ltr">code</span>><span dir="ltr">bubble_sort(fruits</span>)</<span dir="ltr">code</span>></<span dir="ltr">span</span>>:** אני מיישם את אלגוריתם מיון בועות, שבו פירות סמוכים מושווים ומוחלפים אם הם בסדר שגוי.</li>
<li dir="rtl">**<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><<span dir="ltr">code</span>><span dir="ltr">insertion_sort(fruits</span>)</<span dir="ltr">code</span>></<span dir="ltr">span</span>>:** אני מיישם את אלגוריתם מיון הכנסה, שבו כל פרי חדש מוכנס למקום הנכון בחלק הממוין כבר של הרשימה.</li>
<li dir="rtl">**<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><<span dir="ltr">code</span>><span dir="ltr">selection_sort(fruits</span>)</<span dir="ltr">code</span>></<span dir="ltr">span</span>>:** אני מיישם את אלגוריתם מיון בחירה, שבו בכל מעבר אני מוצא את הפרי הקטן ביותר ומציב אותו במקום הנכון.</li>
<li dir="rtl">**<<span dir="ltr">span</span> <span dir="ltr">dir</span>="<span dir="ltr">ltr</span>"><<span dir="ltr">code</span>><span dir="ltr">display_fruits(fruits</span>)</<span dir="ltr">code</span>></<span dir="ltr">span</span>>:** פונקציה זו ממירה רשימת פירות למחרוזת לצורך פלט נוח.</li>
<li dir="rtl">**דוגמאות:** בסוף, אני יוצר רשימת פירות ומיישם עליה את כל שלושת אלגוריתמי המיון, ומדפיס את תוצאות כל אחד מהם. אני גם מראה לך את הסדר שבו הפירות ממוינים.</li>